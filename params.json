{"name":"RestBus","tagline":"Easy Asynchronous Messaging and Queueing for .Net","body":"RestBus enables you to consume your ServiceStack and WebAPI service endpoints via RabbitMQ.  \r\nWith RestBus, queuing or sending a message asynchronously is as simple as:\r\n\r\n```csharp\r\nvar amqpUrl = \"amqp:localhost:5672\"; //AMQP URL for RabbitMQ installation\r\nvar serviceName = \"madagascar\"; //The unique identifier for the target service\r\n\r\nRestBusClient client = new RestBusClient(new BasicMessageMapper(amqpUrl, serviceName));\r\nvar response = client.GetAsync(\"/hello/random\", null).Result;\r\n```\r\n\r\nDoes that look familiar?  \r\nIf you've ever used <a href=\"http://msdn.microsoft.com/en-us/library/system.net.http.httpclient(v=vs.110).aspx\" target=\"_blank\">.NET's HttpClient</a>, you'll be right at home with the `RestBusClient` class. In fact they derive from the same base class.\r\n\r\n\r\n###Why do I need this?###\r\n\r\n\r\n###Features/Advantages###\r\n\r\n**Zero Configuration**\r\n\r\n**Use your Existing Web Services**\r\n\r\n**Concurrent Processing**\r\n\r\n\r\n\r\n\r\n###Getting Started###\r\n\r\n<a href=\"http://github.com/tenor/RestBus/wiki/RabbitMQ-callable-Self-hosting-ServiceStack-service\" target=\"_blank\">Using RestBus in a Self-Hosted ServiceStack Service</a>\r\n ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}