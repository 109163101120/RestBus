{"name":"RestBus","tagline":"Easy Asynchronous Messaging and Queueing for .Net","body":"RestBus enables you to consume your WebAPI and ServiceStack service endpoints via RabbitMQ.  \r\nWith RestBus, queuing or sending a message asynchronously is as simple as:\r\n\r\n```csharp\r\nvar amqpUrl = \"amqp:localhost:5672\"; //AMQP URL for RabbitMQ server\r\nvar serviceName = \"madagascar\"; //The unique identifier for the target service\r\n\r\nvar client = new RestBusClient(new BasicMessageMapper(amqpUrl, serviceName));\r\n\r\n//Call the /hello/random endpoint\r\nvar response = client.GetAsync(\"/hello/random\", null).Result;\r\n```\r\n\r\nDoes that look familiar?  \r\nIf you're conversant with <a href=\"http://msdn.microsoft.com/en-us/library/system.net.http.httpclient(v=vs.110).aspx\" target=\"_blank\">.NET's HttpClient</a> class, you'll be right at home with the `RestBusClient` class. In fact they both derive from the same base class.  \r\nYes, `RestBusClient` is a HTTP client. It just happens to route HTTP messages through RabbitMQ.\r\n\r\n\r\n##Why do I need this?##\r\n\r\n\r\n##Features##\r\n\r\n###Zero Configuration###\r\n\r\n###Use your Existing Web Services###\r\n\r\n- If you are already making calls with the `HttpClient` class, simply switch the client to a `RestBusClient` class and your messages will be routed through RabbitMQ.\r\n\r\n###Concurrent Processing###\r\n\r\n###Horizontal scaling###\r\n\r\n###It's Fast###\r\nRestBus pools RabbitMQ channels for even faster throughput.\r\n[Add test speeds]\r\n\r\n###Customizable###\r\nRoll your own MessageMapper class for custom messaging behavior.\r\n\r\n##How it works##\r\n\r\n##Getting Started##\r\n\r\n<a href=\"http://github.com/tenor/RestBus/wiki/RabbitMQ-callable-Self-hosting-ServiceStack-service\" target=\"_blank\">Using RestBus in a Self-Hosted ServiceStack Service</a>\r\n \r\n\r\n##Advanced Usage##","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}